{"body":"Pythy\r\n=====\r\n\r\nHaving it all now: Pythy syntax for C++11. \r\n\r\nOverview\r\n--------\r\n\r\nIn a [blog post](http://cpp-next.com/archive/2011/11/having-it-all-pythy-syntax/), David Abrahams discussed an improved function syntax based around polymorphic lambdas:\r\n```c++\r\n[]min(x, y)\r\n{ return x < y ? x : y; }\r\n```\r\nThe pythy library implements this in C++11 using a macro like this:\r\n```c++\r\nPYTHY(min, x, y)\r\n( return x < y ? x : y; )\r\n```\r\nInternally, it uses references for each of the parameters. To make each parameter const, the const keyword can be written:\r\n```c++\r\nPYTHY(min, const x, const y)\r\n( return x < y ? x : y; )\r\n```\r\nIf mutablility needs to be forced, the `mutable` keyword can be used:\r\n```c++\r\nPYTHY(add, mutable x, y)\r\n(\r\n    x += y;\r\n)\r\n```\r\nReferences can't be used, since a reference is already being used internally. \r\n\r\nBy default, pythy functions decay their return value, just like lambdas; so they always return by value, However, the `pythy::ref` function can be used to return a reference:\r\n```c++\r\nPYTHY(first, r)\r\n(\r\n    return pythy::ref(*(begin(r)));\r\n)\r\n```\r\n\r\nThis macro is much more powerful than using the simple `RETURNS` macro, like below: \r\n```c++\r\n#define RETURNS(...) -> decltype(__VA_ARGS__) { return (__VA_ARGS__); }\r\ntemplate<class T, class U>\r\nauto min(T x, U y) RETURNS(x < y ? x : y)\r\n```\r\nFor example, a multi-statement function can be written:\r\n```c++\r\nPYTHY(first, r)\r\n(\r\n    if (r.empty()) throw \"The range is empty\";\r\n    return pythy::ref(*(begin(r)));\r\n)\r\n```\r\nOr a function that returns lambda can be written:\r\n```c++\r\nPYTHY(equal_to, x)\r\n(\r\n    return [=](decltype(x) y) { return x == y; }\r\n)\r\n```\r\nWhich can not be done using the `RETURNS` macro.\r\n\r\nImplementation\r\n--------------\r\n\r\nThis is implemented using a templated lambda. Lambdas can't be templated locally(and neither can classes), but we can make a lambda depend on a template parameter. So, if we define a lambda inside a templated class, like this:\r\n```c++\r\ntemplate<class T0, class T1>\r\nstruct min_t\r\n{\r\n    constexpr static auto f = [](T0 x, T1 y){ return x < y ? x : y; }; \r\n};\r\n```\r\nThis won't work, because a lambda closure(even if its non-capturing) is not a constexpr. However, using a trick(as suggested by Richard Smith from clang) we can initialize it as a null pointer:\r\n```c++\r\ntemplate<typename T> \r\ntypename std::remove_reference<T>::type *addr(T &&t) \r\n{ \r\n    return &t; \r\n}\r\ntemplate<class T0, class T1>\r\nstruct min_t\r\n{\r\n    constexpr static auto *f = false ? addr([](T0 x, T1 y){ return x < y ? x : y; }) : nullptr; \r\n};\r\n```\r\nThen when we want to call our function, we can do this:\r\n```c++\r\ntemplate<class T0, class T1>\r\nauto min(T0 x, T1 x) RETURNS((*min_t<T0, T1>::f)(x, y))\r\n```\r\nIt appears that we are derefencing a null pointer. Remember in C++ when dereferencing a null pointer, undefined behavior occurs when there is an lvalue-to-rvalue conversion. However, since a non-capturing lambda closure is almost always implemented as an object with no members, undefined behavior never occurs, since it won't access any of its members. Its highly unlikely that a non-capturing lambda closure could be implemented another way since it must be convertible to a function pointer. But the library does statically assert that the closure object is empty to avoid any possible undefined behavior.\r\n\r\nRequirements\r\n------------\r\n\r\nThis requires a compiler that supports `auto`, `constexpr` and lambdas. It also relies on boost. For some compilers the `-DBOOST_PP_VARIADICS=1` must be passed into the compiler. ","name":"Pythy","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","tagline":"Having it all now: Pythy syntax for C++11"}